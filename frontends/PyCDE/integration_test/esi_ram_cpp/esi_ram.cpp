// REQUIRES: esi-cosim

// clang-format off

// Create ESI system
// RUN: rm -rf %t
// RUN: %PYTHON% %S/../esi_ram.py %t 2>&1

// Create ESI CPP API
// ...
// RUN: cp %S/CMakeLists.txt %t
// RUN: cp %s %t
// RUN: cmake -S %t -B %T/build -DCIRCT_DIR=%CIRCT_SOURCE%

// Run test
// RN: esi-cosim-runner.py --tmpdir %t --schema %t/hw/schema.capnp %s %t/hw/*.sv
// RN: ./%T/build/esi_ram_test %t %t/hw/schema.capnp

// clang-format on
#include <any>
#include <assert.h>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "circt/Dialect/ESI/Runtime/cosim/capnp.h"

#include "hw/schema.capnp.h"

namespace ESIMem {

// Generated things for the current ESI system.

class ESITypes {
public:
  // "pretty" types to wrap Cap'n Proto madness types. Can easily be
  // autogenerated based on the input schema.
  struct I1 {
    // Data members.
    bool i;

    I1(bool i) : i(i) {}
    I1() = default;

    // Unary types have convenience conversion operators.
    operator bool() const { return i; }

    // Spaceship operator for comparison convenience.
    auto operator<=>(const I1 &) const = default;

    // Generated sibling type.
    using CPType = ::I1;
    void fillCapnp(CPType::Builder cp) { cp.setI(i); }
    static I1 fromCapnp(CPType::Reader msg) { return I1(msg.getI()); }
  };

  struct I3 {
    using CPType = ::I3;
    uint8_t i;

    // Convenience constructor due to unary type (allows implicit conversion
    // from literals, makes the API a bit less verbose).
    I3(uint8_t i) : i(i) {}
    I3() = default;

    operator uint8_t() const { return i; }
    auto operator<=>(const I3 &) const = default;

    void fillCapnp(CPType::Builder cp) { cp.setI(i); }
    static I3 fromCapnp(CPType::Reader msg) { return I3(msg.getI()); }
  };

  struct I64 {
    using CPType = ::I64;
    uint64_t i;
    // use default constructors for all types.
    I64(uint64_t i) : i(i) {}
    I64(int i) : i(i) {}
    I64() = default;
    auto operator<=>(const I64 &) const = default;

    operator uint64_t() const { return i; }
    void fillCapnp(CPType::Builder cp) { cp.setI(i); }
    static I64 fromCapnp(CPType::Reader msg) { return I64(msg.getI()); }
  };

  struct Struct16871797234873963366 {
    uint8_t address;
    uint64_t data;
    auto operator<=>(const Struct16871797234873963366 &) const = default;

    // CapnProto compatability functions.
    using CPType = ::Struct16871797234873963366;
    void fillCapnp(CPType::Builder cp) {
      cp.setAddress(address);
      cp.setData(data);
    }

    static Struct16871797234873963366 fromCapnp(CPType::Reader msg) {
      return Struct16871797234873963366{.address = msg.getAddress(),
                                        .data = msg.getData()};
    }
  };
};

template <typename TBackend>
class MemComms : public circt::esi::runtime::Module<TBackend> {
  using Port = circt::esi::runtime::Port<TBackend>;

public:
  // Port type declarations
  using Tread0 =
      circt::esi::runtime::ReadWritePort</*readType=*/ESITypes::I3,
                                         /*writeType=*/ESITypes::I64, TBackend>;
  using Tread0Ptr = std::shared_ptr<Tread0>;

  using Tloopback0 = circt::esi::runtime::ReadWritePort<
      /*readType=*/ESITypes::Struct16871797234873963366,
      /*writeType=*/ESITypes::Struct16871797234873963366, TBackend>;
  using Tloopback0Ptr = std::shared_ptr<Tloopback0>;

  using Twrite0 = circt::esi::runtime::WritePort<
      /*writeType=*/ESITypes::Struct16871797234873963366, TBackend>;
  using Twrite0Ptr = std::shared_ptr<Twrite0>;

  MemComms(Tread0Ptr read0, Tloopback0Ptr loopback0, Twrite0Ptr write0)
      : circt::esi::runtime::Module<TBackend>({read0, loopback0, write0}),
        read0(read0), loopback0(loopback0), write0(write0) {}

  std::shared_ptr<Tread0> read0;
  std::shared_ptr<Tloopback0> loopback0;
  std::shared_ptr<Twrite0> write0;
};

template <typename TBackend>
class Top {

public:
  Top(TBackend &backend) {
    {
      // memComms initialization
      auto read0 = std::make_shared<circt::esi::runtime::ReadWritePort<
          /*writeType=*/ESITypes::I3,
          /*readType=*/ESITypes::I64, TBackend>>(
          std::vector<std::string>{"read"}, backend, "cosim");

      auto loopback0 = std::make_shared<circt::esi::runtime::ReadWritePort<
          /*writeType=*/ESITypes::Struct16871797234873963366,
          /*readType=*/ESITypes::Struct16871797234873963366, TBackend>>(
          std::vector<std::string>{"loopback"}, backend, "cosim");

      auto write0 = std::make_shared<circt::esi::runtime::WritePort<
          /*readType=*/ESITypes::Struct16871797234873963366, TBackend>>(
          std::vector<std::string>{"write"}, backend, "cosim");
      memComms = std::make_unique<MemComms<TBackend>>(read0, loopback0, write0);
      memComms->init();
    };

  }; // namespace ESIMem

  // std::unique_ptr<DeclareRandomAccessMemory<TBackend>> declram;
  std::unique_ptr<MemComms<TBackend>> memComms;
};

} // namespace ESIMem

namespace esi_test {
// Test namespace - this is all user-written code

using namespace ESIMem;

template <typename TBackend>
int runTest(TBackend &backend) {
  // Connect the ESI system to the provided backend.
  ESIMem::Top top(backend);

  auto write_cmd =
      ESITypes::Struct16871797234873963366{.address = 2, .data = 42};

  auto loopback_result = (*top.memComms->loopback0)(write_cmd);
  if (loopback_result != write_cmd)
    return 1;

  auto read_result = (*top.memComms->read0)(2);
  if (read_result != ESITypes::I64(0))
    return 2;
  read_result = (*top.memComms->read0)(3);
  if (read_result != ESITypes::I64(0))
    return 3;

  (*top.memComms->write0)(write_cmd);
  read_result = (*top.memComms->read0)(2);
  if (read_result != ESITypes::I64(42))
    return 4;
  read_result = (*top.memComms->read0)(3);
  if (read_result != ESITypes::I64(42))
    return 5;

  // Re-write a 0 to the memory (mostly for debugging purposes to allow us to
  // keep the server alive and rerun the test).
  write_cmd = ESITypes::Struct16871797234873963366{.address = 2, .data = 0};
  (*top.memComms->write0)(write_cmd);
  read_result = (*top.memComms->read0)(2);
  if (read_result != ESITypes::I64(0))
    return 6;

  return 0;
}

int run_cosim_test(const std::string &host, unsigned port) {
  // Run test with cosimulation backend.
  circt::esi::runtime::cosim::CosimBackend cosim(host, port);
  return runTest(cosim);
}

} // namespace esi_test

int main(int argc, char **argv) {
  std::string rpchostport;
  if (argc != 2) {
    // Schema not currently used but required by the ESI cosim tester
    std::cerr << "usage: esi_ram_test configfile" << std::endl;
    return 1;
  }

  auto configFile = argv[1];

  // Parse the config file. It contains a line "port : ${port}"
  std::ifstream config(configFile);
  std::string line;
  while (std::getline(config, line)) {
    auto colon = line.find(':');
    if (colon == std::string::npos)
      continue;
    auto key = line.substr(0, colon);
    auto value = line.substr(colon + 1);
    if (key == "port") {
      rpchostport = "localhost:" + value;
      break;
    }
  }

  if (rpchostport.empty()) {
    std::cerr << "Could not find port in config file" << std::endl;
    return 1;
  }

  auto colon = rpchostport.find(':');
  auto host = rpchostport.substr(0, colon);
  auto port = stoi(rpchostport.substr(colon + 1));

  auto res = esi_test::run_cosim_test(host, port);
  if (res != 0) {
    std::cerr << "Test failed with error code " << res << std::endl;
    return 1;
  }
  std::cout << "Test passed" << std::endl;
  return 0;
}
